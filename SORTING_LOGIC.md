# Логика сортировки групп

## Описание

Все группы отображаются в **хронологическом порядке** - от ближайших занятий к более поздним.

**Важно:** Прошедшие занятия с `isRecurring: false` автоматически скрываются и не показываются в списке.

## Как это работает

### 1. Порядок обработки

```
Firestore данные
    ↓
Маппинг (преобразование + расчёт дат для isRecurring)
    ↓
Фильтрация прошедших занятий (только для isRecurring: false)
    ↓
Фильтрация (по времени суток и уровню)
    ↓
Сортировка (по дате и времени)
    ↓
Отображение
```

### 2. Сортировка

Группы сортируются по:
1. **Дате** (от ближайшей к дальней)
2. **Времени начала** (при одинаковой дате)

**Пример порядка:**
```
1. Пн 23.02 10:00
2. Пн 23.02 19:00
3. Вт 24.02 14:00
4. Ср 25.02 09:00
5. Чт 26.02 18:00
```

### 3. Учёт повторяющихся занятий

Для занятий с `isRecurring: true`:
- Сортировка использует **вычисленную** дату, а не исходную из Firestore
- Например, если в Firestore `dateTime: "02.03 19:00"`, но это понедельник и сегодня 15.03, то для сортировки будет использоваться `16.03 19:00`

### 4. Фильтрация прошедших занятий

**Правило:** Занятия с `isRecurring: false` автоматически скрываются, если их дата/время уже прошли.

**Почему повторяющиеся занятия всегда показываются?**
- Для занятий с `isRecurring: true` дата автоматически вычисляется как будущая
- Поэтому они никогда не могут быть в прошлом

**Примеры:**

```javascript
// Сегодня: 23.02.2026 15:00

// ✅ Показывается (будущее)
{ dateTime: "24.02 10:00", isRecurring: false }

// ❌ НЕ показывается (прошлое)
{ dateTime: "22.02 19:00", isRecurring: false }

// ❌ НЕ показывается (сегодня, но время прошло)
{ dateTime: "23.02 10:00", isRecurring: false }

// ✅ Показывается (сегодня, время ещё не наступило)
{ dateTime: "23.02 18:00", isRecurring: false }

// ✅ ВСЕГДА показывается (повторяющееся, дата вычисляется автоматически)
{ dateTime: "02.03 19:00", isRecurring: true }  // → 01.03 19:00 (ближайший понедельник)
```

## Код

### Функция проверки прошедшей даты

```typescript
// /src/utils/dateCalculator.ts
export function isPastDateTime(date: string, time: string): boolean {
  const dateTime = parseGroupDateTime(date, time);
  const now = new Date();
  return dateTime.getTime() < now.getTime();
}
```

### Функция парсинга даты и времени

```typescript
// /src/utils/dateCalculator.ts
export function parseGroupDateTime(date: string, time: string): Date {
  try {
    const [day, month] = date.split('.').map(Number);
    // Берем время начала (до дефиса)
    const startTime = time.split('-')[0];
    const [hours, minutes] = startTime.split(':').map(Number);
    
    const currentYear = new Date().getFullYear();
    const dateObj = new Date(currentYear, month - 1, day, hours, minutes);
    
    return isNaN(dateObj.getTime()) ? new Date() : dateObj;
  } catch {
    return new Date();
  }
}
```

### Применение фильтрации и сортировки

```typescript
// /src/app/App.tsx
const filteredGroups = useMemo(() => {
  return trainings
    .map(mapTrainingToGroup)
    .filter((group) => {
      // Фильтр: не показываем прошедшие занятия с isRecurring: false
      if (!group.isRecurring && isPastDateTime(group.date, group.time)) {
        return false;
      }
      
      // ... остальные фильтры (время суток, уровень)
      return true;
    })
    .sort((a, b) => {
      const dateA = parseGroupDateTime(a.date, a.time);
      const dateB = parseGroupDateTime(b.date, b.time);
      return dateA.getTime() - dateB.getTime();
    });
}, [filters, trainings]);
```

## Примеры

### Пример 1: Обычные занятия

**В Firestore (в разноброс):**
```
1. { dateTime: "25.02 14:00" }
2. { dateTime: "23.02 10:00" }
3. { dateTime: "24.02 19:00" }
```

**В приложении (отсортировано):**
```
1. Вс 23.02 10:00-11:30
2. Пн 24.02 19:00-20:30
3. Вт 25.02 14:00-15:30
```

### Пример 2: Повторяющиеся занятия

**В Firestore (сегодня 22.02):**
```
1. { dateTime: "02.03 19:00", isRecurring: true }  // Понедельник
2. { dateTime: "03.03 18:00", isRecurring: true }  // Вторник
3. { dateTime: "08.03 10:00", isRecurring: true }  // Воскресенье
```

**В приложении (по��ле расчёта и сортировки):**
```
1. Пн 23.02 19:00-20:30  (ближайший понедельник)
2. Вт 24.02 18:00-19:30  (ближайший вторник)
3. Вс 01.03 10:00-11:30  (ближайшее воскресенье)
```

### Пример 3: Смешанные занятия

**В Firestore:**
```
1. { dateTime: "25.02 14:00", isRecurring: false }
2. { dateTime: "02.03 19:00", isRecurring: true }   // Понедельник
3. { dateTime: "24.02 10:00", isRecurring: false }
```

**Сегодня: 22.02 (воскресенье)**

**В приложении:**
```
1. Пн 23.02 19:00  (вычисленная дата, ближайший понедельник)
2. Вт 24.02 10:00  (фиксированная дата)
3. Ср 25.02 14:00  (фиксированная дата)
```

## Важные моменты

### 1. Производительность

- Сортировка происходит в `useMemo`, поэтому пересчитывается только при изменении `filters` или `trainings`
- Парсинг даты кешируется внутри сортировки

### 2. Граничные случаи

**Некорректный формат даты:**
```typescript
// Если дата не распарсилась, возвращается new Date()
// Такие элементы попадут в начало или конец списка
```

**Пустой список:**
```typescript
// Если groups.length === 0, сортировка не выполняется
// Показывается сообщение "Группы не найдены"
```

### 3. Совместимость с фильтрами

Сортировка применяется **после** фильтрации:
1. Применяются фильтры по времени суток
2. Применяются фильтры по уровню игры
3. Результат сортируется

Это означает, что порядок групп всегда хронологический, независимо от активных фильтров.

## Тестирование

Чтобы проверить сортировку:

1. Создайте несколько тренировок с разными датами и временем
2. Убедитесь, что они отображаются в хронологическом порядке
3. Проверьте, что повторяющиеся занятия учитываются правильно
4. Примените фильтры и убедитесь, что сортировка сохраняется

**Пример тестовых данных:**
```javascript
// В Firestore создайте:
[
  { dateTime: "27.02 22:00" },  // Чт вечер
  { dateTime: "23.02 10:00" },  // Вс утро
  { dateTime: "24.02 19:00" },  // Пн вечер
  { dateTime: "25.02 14:00" },  // Вт день
]

// Ожидаемый порядок:
// 1. Вс 23.02 10:00
// 2. Пн 24.02 19:00
// 3. Вт 25.02 14:00
// 4. Чт 27.02 22:00
```

## Будущие улучшения

Возможные дополнения:

1. **Опция сортировки** - позволить пользователю выбирать порядок (по дате, по цене, по уровню)
2. **Группировка по датам** - разделить группы по дням недели
3. **Приоритет** - показывать занятия с малым количеством свободных мест первыми
4. **Персонализация** - сортировать по предпочтениям пользователя (сохраненные тренеры, уровень)